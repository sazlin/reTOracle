import time
import json
import psycopg2
import SECRETS
from tweepy.streaming import StreamListener
from tweepy import OAuthHandler
from tweepy import Stream
from header import consumer_key, consumer_secret, access_token, access_token_secret


req_tok_url = 'https://api.twitter.com/oauth/request_token'
oauth_url = 'https://api.twitter.com/oauth/authorize'
acc_tok_url = 'https://api.twitter.com/oauth/access_token'


class StdOutListener(StreamListener):
    """ A listener handles tweets are the received from the stream.
    This is a basic listener that just prints received tweets to stdout.

    """
    def __init__(self):
        self.connect_db()

    def connect_db(self):
        try:
            connection_string = []
            connection_string.append("host=rhetoracle-db-instance.c2vrlkt9v1tp.us-west-2.rds.amazonaws.com")
            connection_string.append("dbname=rhetorical-db")
            connection_string.append("user=" + SECRETS['DB_USERNAME'])
            connection_string.append("password=" + SECRETS['DB_PASSWORD'])
            self.con = psycopg2.connect(" ".join(connection_string))
            self.cur = self.con.cursor()
        except Exception as x:
            print "Error connecting to DB: ", x.args

    def fix_tweet_id(self, tweet_id):
        return str(tweet_id)

    def fix_lists(self, hashtags):
        str1 = '{'
        hashtags = ", ".join(hashtags)
        str1 += hashtags
        str1 += '}'
        return str1

    def fix_location(self, location):
        str1 = '['
        location = ", ".join(location)
        str1 += location
        str1 += ']'
        return str1

    def on_data(self, data):

        # load json_data
        json_data = json.loads(data)

        # need to convert for SQL
        tweet_id = json_data.get('id', None)
        tweet_id = self.fix_tweet_id(tweet_id)

        text = json_data.get('text', None)

        hashtags = [i['text'] for i in json_data.get('entities', None).get('hashtags', None)]
        hashtags = self.fix_lists(hashtags)

        user_mentions = [i['screen_name'] for i in json_data.get('entities', None).get('user_mentions', None)]
        user_mentions = self.fix_lists(user_mentions)

        created_at = json_data.get('created_at', None)
        screen_name = json_data.get('user', None).get('screen_name', None)

        urls = [i['display_url'] for i in json_data.get('entities', None).get('urls', None)]
        urls = self.fix_lists(urls)

        location = json_data.get('geo', None)
        if location:
            location = location.get('coordinates', None)
            location = self.fix_location(location)
        if not location:
            location = ''

        in_reply_to_screen_name = json_data.get('in_reply_to_screen_name', None)
        if not in_reply_to_screen_name:
            in_reply_to_screen_name = ''

        retweets = json_data.get('retweet_count', None)

        PUSH_SQL = """
            INSERT INTO massive(
                tweet_id, text, hashtags, user_mentions,
                created_at, screen_name, urls, location,
                inreplytostatusif, retweetcount)

            VALUES(
                '{}', '{}', '{}', '{}', '{}', '{}', '{}',
                '{}', '{}', {}); """

        PUSH_SQL = PUSH_SQL.format(tweet_id, text, hashtags, user_mentions,
                                   created_at, screen_name, urls, location,
                                   in_reply_to_screen_name, retweets)

        # write to database

        try:
            self.cur.execute(PUSH_SQL)
        except psycopg2.Error:
            # this will catch any errors generated by the database
            print "Oops there was a DB error!"
        else:
            self.con.commit()

    def on_error(self, status):
        error_counter = 0
        if status == 420:
            time.sleep(15)
            print "Made too many requests!"
            print '*' * 20
            error_counter += 1
            print "Errors: ", error_counter

if __name__ == '__main__':
    l = StdOutListener()
    auth = OAuthHandler(consumer_key, consumer_secret)
    auth.set_access_token(access_token, access_token_secret)

    stream = Stream(auth, l)
    stream.filter(track=['Python', 'Seattle'])
